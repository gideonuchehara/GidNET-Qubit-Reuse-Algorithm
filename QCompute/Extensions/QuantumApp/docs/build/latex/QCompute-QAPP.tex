%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}


\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{tgtermes}
\usepackage{tgheros}
\renewcommand{\ttdefault}{txtt}



\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=auto}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{API Docs}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{QCompute-QAPP Documentation}
\date{Apr 13, 2023}
\release{0.0.1}
\author{Institute for Quantum Computing, Baidu Inc.}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\sphinxstepscope

\sphinxstepscope


\chapter{QCompute\sphinxhyphen{}QAPP Package}
\label{\detokenize{qcompute_qapp:qcompute-qapp-package}}\label{\detokenize{qcompute_qapp::doc}}\label{\detokenize{qcompute_qapp::doc}}
\sphinxstepscope


\section{\sphinxstyleliteralintitle{\sphinxupquote{qcompute\_qapp.algorithm}}}
\label{\detokenize{qcompute_qapp.algorithm:module-qcompute_qapp.algorithm}}\label{\detokenize{qcompute_qapp.algorithm:qcompute-qapp-algorithm}}\label{\detokenize{qcompute_qapp.algorithm::doc}}\index{module@\spxentry{module}!qcompute\_qapp.algorithm@\spxentry{qcompute\_qapp.algorithm}}\index{qcompute\_qapp.algorithm@\spxentry{qcompute\_qapp.algorithm}!module@\spxentry{module}}
\sphinxAtStartPar
The variational quantum algorithm library
\index{VQE (class in qcompute\_qapp.algorithm)@\spxentry{VQE}\spxextra{class in qcompute\_qapp.algorithm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.algorithm:qcompute_qapp.algorithm.VQE}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{qcompute\_qapp.algorithm.}}\sphinxbfcode{\sphinxupquote{VQE}}}{\emph{\DUrole{n}{num}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{hamiltonian}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{list}}, \emph{\DUrole{n}{ansatz}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.ParameterizedCircuit}]{\sphinxcrossref{ParameterizedCircuit}}}}}, \emph{\DUrole{n}{optimizer}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{qcompute_qapp.optimizer:qcompute_qapp.optimizer.BasicOptimizer}]{\sphinxcrossref{BasicOptimizer}}}}}, \emph{\DUrole{n}{backend}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}}, \emph{\DUrole{n}{measurement}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}default\textquotesingle{}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Variational Quantum Eigensolver class

\sphinxAtStartPar
The constructor of the VQE class
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{num}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of qubits

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hamiltonian}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} Hamiltonian whose minimum eigenvalue is to be solved

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ansatz}} ({\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.ParameterizedCircuit}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{ParameterizedCircuit}}}}}) \textendash{} Ansatz used to search for the ground state of the Hamiltonian

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{optimizer}} ({\hyperref[\detokenize{qcompute_qapp.optimizer:qcompute_qapp.optimizer.BasicOptimizer}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{BasicOptimizer}}}}}) \textendash{} Optimizer used to optimize the parameters in the ansatz

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{backend}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Backend to be used in this task. Please refer to \sphinxurl{https://quantum-hub.baidu.com/quickGuide}
for details

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{measurement}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Method chosen from ‘default’, ‘ancilla’, and ‘SimMeasure’ for measuring the expectation
value, defaults to ‘default’

\end{itemize}

\end{description}\end{quote}
\index{get\_measure() (qcompute\_qapp.algorithm.VQE method)@\spxentry{get\_measure()}\spxextra{qcompute\_qapp.algorithm.VQE method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.algorithm:qcompute_qapp.algorithm.VQE.get_measure}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_measure}}}{\emph{\DUrole{n}{shots}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{1024}}}{{ $\rightarrow$ dict}}
\pysigstopsignatures
\sphinxAtStartPar
Returns the measurement results
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shots}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of measurement shots, defaults to 1024

\sphinxlineitem{Returns}
\sphinxAtStartPar
Measurement results in bitstrings with the number of counts

\sphinxlineitem{Return type}
\sphinxAtStartPar
dict

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_gradient() (qcompute\_qapp.algorithm.VQE method)@\spxentry{get\_gradient()}\spxextra{qcompute\_qapp.algorithm.VQE method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.algorithm:qcompute_qapp.algorithm.VQE.get_gradient}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_gradient}}}{\emph{\DUrole{n}{shots}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{1024}}}{{ $\rightarrow$ ndarray}}
\pysigstopsignatures
\sphinxAtStartPar
Calculates the gradient with respect to current parameters in circuit
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shots}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of measurement shots, defaults to 1024

\sphinxlineitem{Returns}
\sphinxAtStartPar
Gradient with respect to current parameters

\sphinxlineitem{Return type}
\sphinxAtStartPar
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_loss() (qcompute\_qapp.algorithm.VQE method)@\spxentry{get\_loss()}\spxextra{qcompute\_qapp.algorithm.VQE method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.algorithm:qcompute_qapp.algorithm.VQE.get_loss}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_loss}}}{\emph{\DUrole{n}{shots}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{1024}}}{{ $\rightarrow$ float}}
\pysigstopsignatures
\sphinxAtStartPar
Calculates the loss with respect to current parameters in circuit
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shots}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of measurement shots, defaults to 1024

\sphinxlineitem{Returns}
\sphinxAtStartPar
Loss with respect to current parameters

\sphinxlineitem{Return type}
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}

\index{run() (qcompute\_qapp.algorithm.VQE method)@\spxentry{run()}\spxextra{qcompute\_qapp.algorithm.VQE method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.algorithm:qcompute_qapp.algorithm.VQE.run}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{\DUrole{n}{shots}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{1024}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Searches for the minimum eigenvalue of the input Hamiltonian with the given ansatz and optimizer
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shots}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of measurement shots, defaults to 1024

\end{description}\end{quote}

\end{fulllineitems}

\index{minimum\_eigenvalue (qcompute\_qapp.algorithm.VQE property)@\spxentry{minimum\_eigenvalue}\spxextra{qcompute\_qapp.algorithm.VQE property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.algorithm:qcompute_qapp.algorithm.VQE.minimum_eigenvalue}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{property\DUrole{w}{  }}}\sphinxbfcode{\sphinxupquote{minimum\_eigenvalue}}\sphinxbfcode{\sphinxupquote{\DUrole{p}{:}\DUrole{w}{  }Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }float\DUrole{p}{{]}}}}}
\pysigstopsignatures
\sphinxAtStartPar
The optimized minimum eigenvalue from last run
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Optimized minimum eigenvalue from last run

\sphinxlineitem{Return type}
\sphinxAtStartPar
Union{[}str, float{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_backend() (qcompute\_qapp.algorithm.VQE method)@\spxentry{set\_backend()}\spxextra{qcompute\_qapp.algorithm.VQE method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.algorithm:qcompute_qapp.algorithm.VQE.set_backend}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_backend}}}{\emph{\DUrole{n}{backend}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Sets the backend to be used
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{backend}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Backend to be used

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{SSVQE (class in qcompute\_qapp.algorithm)@\spxentry{SSVQE}\spxextra{class in qcompute\_qapp.algorithm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.algorithm:qcompute_qapp.algorithm.SSVQE}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{qcompute\_qapp.algorithm.}}\sphinxbfcode{\sphinxupquote{SSVQE}}}{\emph{\DUrole{n}{num}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{ex\_num}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{hamiltonian}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{list}}, \emph{\DUrole{n}{ansatz}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.ParameterizedCircuit}]{\sphinxcrossref{ParameterizedCircuit}}}}}, \emph{\DUrole{n}{optimizer}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{qcompute_qapp.optimizer:qcompute_qapp.optimizer.BasicOptimizer}]{\sphinxcrossref{BasicOptimizer}}}}}, \emph{\DUrole{n}{backend}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}}, \emph{\DUrole{n}{measurement}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}default\textquotesingle{}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Subspace\sphinxhyphen{}Search Variational Quantum Eigensolver class

\sphinxAtStartPar
Please see \sphinxurl{https://journals.aps.org/prresearch/abstract/10.1103/PhysRevResearch.1.033062} for details on this algorithm.

\sphinxAtStartPar
The constructor of the SSVQE class
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{num}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of qubits

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ex\_num}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of extra eignevalues to be solved. When ex\_num = 0, only compute the minimum eigenvalue

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hamiltonian}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} Hamiltonian whose eigenvalues are to be solved

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ansatz}} ({\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.ParameterizedCircuit}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{ParameterizedCircuit}}}}}) \textendash{} Ansatz used to search for the eigenstates of the Hamiltonian

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{optimizer}} ({\hyperref[\detokenize{qcompute_qapp.optimizer:qcompute_qapp.optimizer.BasicOptimizer}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{BasicOptimizer}}}}}) \textendash{} Optimizer used to optimize the parameters in the ansatz

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{backend}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Backend to be used in this task. Please refer to \sphinxurl{https://quantum-hub.baidu.com/quickGuide}
for details

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{measurement}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Method chosen from ‘default’, ‘ancilla’, and ‘SimMeasure’ for measuring the expectation
value, defaults to ‘default’

\end{itemize}

\end{description}\end{quote}
\index{get\_gradient() (qcompute\_qapp.algorithm.SSVQE method)@\spxentry{get\_gradient()}\spxextra{qcompute\_qapp.algorithm.SSVQE method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.algorithm:qcompute_qapp.algorithm.SSVQE.get_gradient}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_gradient}}}{\emph{\DUrole{n}{shots}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{1024}}}{{ $\rightarrow$ ndarray}}
\pysigstopsignatures
\sphinxAtStartPar
Calculates the gradient with respect to current parameters in circuit
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shots}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of measurement shots, defaults to 1024

\sphinxlineitem{Returns}
\sphinxAtStartPar
Gradient with respect to current parameters

\sphinxlineitem{Return type}
\sphinxAtStartPar
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_loss() (qcompute\_qapp.algorithm.SSVQE method)@\spxentry{get\_loss()}\spxextra{qcompute\_qapp.algorithm.SSVQE method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.algorithm:qcompute_qapp.algorithm.SSVQE.get_loss}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_loss}}}{\emph{\DUrole{n}{shots}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{1024}}}{{ $\rightarrow$ float}}
\pysigstopsignatures
\sphinxAtStartPar
Calculates the loss with respect to current parameters in circuit
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shots}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of measurement shots, defaults to 1024

\sphinxlineitem{Returns}
\sphinxAtStartPar
Loss with respect to current parameters

\sphinxlineitem{Return type}
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}

\index{run() (qcompute\_qapp.algorithm.SSVQE method)@\spxentry{run()}\spxextra{qcompute\_qapp.algorithm.SSVQE method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.algorithm:qcompute_qapp.algorithm.SSVQE.run}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{\DUrole{n}{shots}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{1024}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Searches for the minimum eigenvalue of the input Hamiltonian with the given ansatz and optimizer
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shots}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of measurement shots, defaults to 1024

\end{description}\end{quote}

\end{fulllineitems}

\index{minimum\_eigenvalues (qcompute\_qapp.algorithm.SSVQE property)@\spxentry{minimum\_eigenvalues}\spxextra{qcompute\_qapp.algorithm.SSVQE property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.algorithm:qcompute_qapp.algorithm.SSVQE.minimum_eigenvalues}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{property\DUrole{w}{  }}}\sphinxbfcode{\sphinxupquote{minimum\_eigenvalues}}\sphinxbfcode{\sphinxupquote{\DUrole{p}{:}\DUrole{w}{  }Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }list\DUrole{p}{{]}}}}}
\pysigstopsignatures
\sphinxAtStartPar
The optimized minimum eigenvalue from last run
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Optimized minimum eigenvalues from last run

\sphinxlineitem{Return type}
\sphinxAtStartPar
Union{[}str, list{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_backend() (qcompute\_qapp.algorithm.SSVQE method)@\spxentry{set\_backend()}\spxextra{qcompute\_qapp.algorithm.SSVQE method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.algorithm:qcompute_qapp.algorithm.SSVQE.set_backend}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_backend}}}{\emph{\DUrole{n}{backend}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Sets the backend to be used
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{backend}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Backend to be used

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{QAOA (class in qcompute\_qapp.algorithm)@\spxentry{QAOA}\spxextra{class in qcompute\_qapp.algorithm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.algorithm:qcompute_qapp.algorithm.QAOA}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{qcompute\_qapp.algorithm.}}\sphinxbfcode{\sphinxupquote{QAOA}}}{\emph{\DUrole{n}{num}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{hamiltonian}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{list}}, \emph{\DUrole{n}{ansatz}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.QAOAAnsatz}]{\sphinxcrossref{QAOAAnsatz}}}}}, \emph{\DUrole{n}{optimizer}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{qcompute_qapp.optimizer:qcompute_qapp.optimizer.BasicOptimizer}]{\sphinxcrossref{BasicOptimizer}}}}}, \emph{\DUrole{n}{backend}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}}, \emph{\DUrole{n}{measurement}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}default\textquotesingle{}}}, \emph{\DUrole{n}{delta}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{float}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{0.1}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Quantum Approximate Optimization Algorithm class

\sphinxAtStartPar
The constructor of the QAOA class
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{num}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of qubits

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hamiltonian}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} Hamiltonian used to construct the QAOA ansatz

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{ansatz}} ({\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.QAOAAnsatz}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{QAOAAnsatz}}}}}) \textendash{} QAOA ansatz used to search for the maximum eigenstate of the Hamiltonian
optimizer (BasicOptimizer): Optimizer used to optimize the parameters in the ansatz

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{backend}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Backend to be used in this task. Please refer to \sphinxurl{https://quantum-hub.baidu.com/quickGuide}
for details

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{measurement}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Method chosen from ‘default’, ‘ancilla’, and ‘SimMeasure’ for measuring the expectation
value, defaults to ‘default’

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{delta}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Parameter used to calculate gradients, defaults to 0.1

\end{itemize}

\end{description}\end{quote}
\index{get\_measure() (qcompute\_qapp.algorithm.QAOA method)@\spxentry{get\_measure()}\spxextra{qcompute\_qapp.algorithm.QAOA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.algorithm:qcompute_qapp.algorithm.QAOA.get_measure}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_measure}}}{\emph{\DUrole{n}{shots}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{1024}}}{{ $\rightarrow$ dict}}
\pysigstopsignatures
\sphinxAtStartPar
Returns the measurement results
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shots}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of measurement shots, defaults to 1024

\sphinxlineitem{Returns}
\sphinxAtStartPar
Measurement results in bitstrings with the number of counts

\sphinxlineitem{Return type}
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_gradient() (qcompute\_qapp.algorithm.QAOA method)@\spxentry{get\_gradient()}\spxextra{qcompute\_qapp.algorithm.QAOA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.algorithm:qcompute_qapp.algorithm.QAOA.get_gradient}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_gradient}}}{\emph{\DUrole{n}{shots}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{1024}}}{{ $\rightarrow$ ndarray}}
\pysigstopsignatures
\sphinxAtStartPar
Calculates the gradient with respect to current parameters in circuit
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shots}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of measurement shots, defaults to 1024

\sphinxlineitem{Returns}
\sphinxAtStartPar
Gradient with respect to current parameters

\sphinxlineitem{Return type}
\sphinxAtStartPar
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_loss() (qcompute\_qapp.algorithm.QAOA method)@\spxentry{get\_loss()}\spxextra{qcompute\_qapp.algorithm.QAOA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.algorithm:qcompute_qapp.algorithm.QAOA.get_loss}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_loss}}}{\emph{\DUrole{n}{shots}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{1024}}}{{ $\rightarrow$ float}}
\pysigstopsignatures
\sphinxAtStartPar
Calculates the loss with respect to current parameters in circuit
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shots}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of measurement shots, defaults to 1024

\sphinxlineitem{Returns}
\sphinxAtStartPar
Loss with respect to current parameters

\sphinxlineitem{Return type}
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}

\index{run() (qcompute\_qapp.algorithm.QAOA method)@\spxentry{run()}\spxextra{qcompute\_qapp.algorithm.QAOA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.algorithm:qcompute_qapp.algorithm.QAOA.run}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{run}}}{\emph{\DUrole{n}{shots}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{1024}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Searches for the maximum eigenvalue of the input Hamiltonian with the given ansatz and optimizer
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shots}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of measurement shots, defaults to 1024

\end{description}\end{quote}

\end{fulllineitems}

\index{maximum\_eigenvalue (qcompute\_qapp.algorithm.QAOA property)@\spxentry{maximum\_eigenvalue}\spxextra{qcompute\_qapp.algorithm.QAOA property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.algorithm:qcompute_qapp.algorithm.QAOA.maximum_eigenvalue}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{property\DUrole{w}{  }}}\sphinxbfcode{\sphinxupquote{maximum\_eigenvalue}}\sphinxbfcode{\sphinxupquote{\DUrole{p}{:}\DUrole{w}{  }Union\DUrole{p}{{[}}str\DUrole{p}{,}\DUrole{w}{  }float\DUrole{p}{{]}}}}}
\pysigstopsignatures
\sphinxAtStartPar
The optimized maximum eigenvalue from last run
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Optimized maximum eigenvalue from last run

\sphinxlineitem{Return type}
\sphinxAtStartPar
Union{[}str, float{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_backend() (qcompute\_qapp.algorithm.QAOA method)@\spxentry{set\_backend()}\spxextra{qcompute\_qapp.algorithm.QAOA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.algorithm:qcompute_qapp.algorithm.QAOA.set_backend}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_backend}}}{\emph{\DUrole{n}{backend}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Sets the backend to be used
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{backend}} \textendash{} Backend to be used

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{KernelClassifier (class in qcompute\_qapp.algorithm)@\spxentry{KernelClassifier}\spxextra{class in qcompute\_qapp.algorithm}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.algorithm:qcompute_qapp.algorithm.KernelClassifier}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{qcompute\_qapp.algorithm.}}\sphinxbfcode{\sphinxupquote{KernelClassifier}}}{\emph{\DUrole{n}{backend}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}}, \emph{\DUrole{n}{encoding\_style}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}IQP\textquotesingle{}}}, \emph{\DUrole{n}{kernel\_type}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}qke\textquotesingle{}}}, \emph{\DUrole{n}{shots}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{1024}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Kernel Classifier class

\sphinxAtStartPar
The constructor of the KernelClassifier class
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{backend}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Backend to be used in this task. Please refer to \sphinxurl{https://quantum-hub.baidu.com/quickGuide}
for details

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{encoding\_style}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Encoding scheme to be used, defaults to ‘IQP’, which uses the default encoding scheme

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{kernel\_type}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Type of kernel to be used, defaults to ‘qke’, i.e., \textless{}x1|x2\textgreater{}

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shots}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of measurement shots, defaults to 1024

\end{itemize}

\end{description}\end{quote}
\index{fit() (qcompute\_qapp.algorithm.KernelClassifier method)@\spxentry{fit()}\spxextra{qcompute\_qapp.algorithm.KernelClassifier method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.algorithm:qcompute_qapp.algorithm.KernelClassifier.fit}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{fit}}}{\emph{\DUrole{n}{X}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{ndarray}}, \emph{\DUrole{n}{y}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{ndarray}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Trains the classifier with known data
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{X}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Set of classical data vectors as the training data

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{y}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Known labels of the training data

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{predict() (qcompute\_qapp.algorithm.KernelClassifier method)@\spxentry{predict()}\spxextra{qcompute\_qapp.algorithm.KernelClassifier method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.algorithm:qcompute_qapp.algorithm.KernelClassifier.predict}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{predict}}}{\emph{\DUrole{n}{x}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{ndarray}}}{{ $\rightarrow$ ndarray}}
\pysigstopsignatures
\sphinxAtStartPar
Predicts labels of new data
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Set of data vectors with unknown labels

\sphinxlineitem{Returns}
\sphinxAtStartPar
Predicted labels of the input data

\sphinxlineitem{Return type}
\sphinxAtStartPar
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\section{\sphinxstyleliteralintitle{\sphinxupquote{qcompute\_qapp.application}}}
\label{\detokenize{qcompute_qapp.application:qcompute-qapp-application}}\label{\detokenize{qcompute_qapp.application::doc}}
\sphinxstepscope


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{qcompute\_qapp.application.chemistry}}}
\label{\detokenize{qcompute_qapp.application.chemistry:module-qcompute_qapp.application.chemistry}}\label{\detokenize{qcompute_qapp.application.chemistry:qcompute-qapp-application-chemistry}}\label{\detokenize{qcompute_qapp.application.chemistry::doc}}\index{module@\spxentry{module}!qcompute\_qapp.application.chemistry@\spxentry{qcompute\_qapp.application.chemistry}}\index{qcompute\_qapp.application.chemistry@\spxentry{qcompute\_qapp.application.chemistry}!module@\spxentry{module}}
\sphinxAtStartPar
The function about quantum chemistry
\index{MolecularGroundStateEnergy (class in qcompute\_qapp.application.chemistry)@\spxentry{MolecularGroundStateEnergy}\spxextra{class in qcompute\_qapp.application.chemistry}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.application.chemistry:qcompute_qapp.application.chemistry.MolecularGroundStateEnergy}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{qcompute\_qapp.application.chemistry.}}\sphinxbfcode{\sphinxupquote{MolecularGroundStateEnergy}}}{\emph{\DUrole{n}{num\_qubits}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{0}}, \emph{\DUrole{n}{hamiltonian}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Optional\DUrole{p}{{[}}list\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Molecular Ground State Energy class

\sphinxAtStartPar
The constructor of the MolecularGroundStateEnergy class
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{num\_qubits}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of qubits, defaults to 0

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hamiltonian}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} Hamiltonian of the molecular system, defaults to None

\end{itemize}

\end{description}\end{quote}
\index{num\_qubits (qcompute\_qapp.application.chemistry.MolecularGroundStateEnergy property)@\spxentry{num\_qubits}\spxextra{qcompute\_qapp.application.chemistry.MolecularGroundStateEnergy property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.application.chemistry:qcompute_qapp.application.chemistry.MolecularGroundStateEnergy.num_qubits}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{property\DUrole{w}{  }}}\sphinxbfcode{\sphinxupquote{num\_qubits}}\sphinxbfcode{\sphinxupquote{\DUrole{p}{:}\DUrole{w}{  }int}}}
\pysigstopsignatures
\sphinxAtStartPar
The number of qubits used to encoding this molecular system
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Number of qubits

\sphinxlineitem{Return type}
\sphinxAtStartPar
int

\end{description}\end{quote}

\end{fulllineitems}

\index{hamiltonian (qcompute\_qapp.application.chemistry.MolecularGroundStateEnergy property)@\spxentry{hamiltonian}\spxextra{qcompute\_qapp.application.chemistry.MolecularGroundStateEnergy property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.application.chemistry:qcompute_qapp.application.chemistry.MolecularGroundStateEnergy.hamiltonian}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{property\DUrole{w}{  }}}\sphinxbfcode{\sphinxupquote{hamiltonian}}\sphinxbfcode{\sphinxupquote{\DUrole{p}{:}\DUrole{w}{  }list}}}
\pysigstopsignatures
\sphinxAtStartPar
The Hamiltonian of this molecular system
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Hamiltonian of this molecular system

\sphinxlineitem{Return type}
\sphinxAtStartPar
list

\end{description}\end{quote}

\end{fulllineitems}

\index{compute\_ground\_state\_energy() (qcompute\_qapp.application.chemistry.MolecularGroundStateEnergy method)@\spxentry{compute\_ground\_state\_energy()}\spxextra{qcompute\_qapp.application.chemistry.MolecularGroundStateEnergy method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.application.chemistry:qcompute_qapp.application.chemistry.MolecularGroundStateEnergy.compute_ground_state_energy}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compute\_ground\_state\_energy}}}{}{{ $\rightarrow$ float}}
\pysigstopsignatures
\sphinxAtStartPar
Analytically computes the ground state energy
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
minimum real part of eigenvalues

\sphinxlineitem{Return type}
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}

\index{load\_hamiltonian\_from\_file() (qcompute\_qapp.application.chemistry.MolecularGroundStateEnergy method)@\spxentry{load\_hamiltonian\_from\_file()}\spxextra{qcompute\_qapp.application.chemistry.MolecularGroundStateEnergy method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.application.chemistry:qcompute_qapp.application.chemistry.MolecularGroundStateEnergy.load_hamiltonian_from_file}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{load\_hamiltonian\_from\_file}}}{\emph{\DUrole{n}{filename}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}}, \emph{\DUrole{n}{separator}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}, \textquotesingle{}}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Loads Hamiltonian from a file
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{filename}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Path to the file storing the Hamiltonian in Pauli terms

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{separator}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Delimiter between coefficient and Pauli string, defaults to ‘, ‘

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{qcompute\_qapp.application.optimization}}}
\label{\detokenize{qcompute_qapp.application.optimization:module-qcompute_qapp.application.optimization}}\label{\detokenize{qcompute_qapp.application.optimization:qcompute-qapp-application-optimization}}\label{\detokenize{qcompute_qapp.application.optimization::doc}}\index{module@\spxentry{module}!qcompute\_qapp.application.optimization@\spxentry{qcompute\_qapp.application.optimization}}\index{qcompute\_qapp.application.optimization@\spxentry{qcompute\_qapp.application.optimization}!module@\spxentry{module}}
\sphinxAtStartPar
The function about optimization
\index{MaxCut (class in qcompute\_qapp.application.optimization)@\spxentry{MaxCut}\spxextra{class in qcompute\_qapp.application.optimization}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.application.optimization:qcompute_qapp.application.optimization.MaxCut}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{qcompute\_qapp.application.optimization.}}\sphinxbfcode{\sphinxupquote{MaxCut}}}{\emph{\DUrole{n}{num\_qubits}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{0}}, \emph{\DUrole{n}{hamiltonian}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Optional\DUrole{p}{{[}}list\DUrole{p}{{]}}}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{None}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{object}}

\sphinxAtStartPar
Max Cut Problem class

\sphinxAtStartPar
The constructor of the MaxCut class
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{num\_qubits}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of qubits, defaults to 0

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hamiltonian}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} Hamiltonian of the target graph of the Max Cut problem, defaults to None

\end{itemize}

\end{description}\end{quote}
\index{num\_qubits (qcompute\_qapp.application.optimization.MaxCut property)@\spxentry{num\_qubits}\spxextra{qcompute\_qapp.application.optimization.MaxCut property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.application.optimization:qcompute_qapp.application.optimization.MaxCut.num_qubits}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{property\DUrole{w}{  }}}\sphinxbfcode{\sphinxupquote{num\_qubits}}\sphinxbfcode{\sphinxupquote{\DUrole{p}{:}\DUrole{w}{  }int}}}
\pysigstopsignatures
\sphinxAtStartPar
The number of qubits used to encoding this target graph
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Number of qubits used to encoding this target graph

\sphinxlineitem{Return type}
\sphinxAtStartPar
int

\end{description}\end{quote}

\end{fulllineitems}

\index{hamiltonian (qcompute\_qapp.application.optimization.MaxCut property)@\spxentry{hamiltonian}\spxextra{qcompute\_qapp.application.optimization.MaxCut property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.application.optimization:qcompute_qapp.application.optimization.MaxCut.hamiltonian}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{property\DUrole{w}{  }}}\sphinxbfcode{\sphinxupquote{hamiltonian}}\sphinxbfcode{\sphinxupquote{\DUrole{p}{:}\DUrole{w}{  }list}}}
\pysigstopsignatures
\sphinxAtStartPar
The Hamiltonian of this target graph
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Hamiltonian of this target graph

\sphinxlineitem{Return type}
\sphinxAtStartPar
list

\end{description}\end{quote}

\end{fulllineitems}

\index{graph\_to\_hamiltonian() (qcompute\_qapp.application.optimization.MaxCut method)@\spxentry{graph\_to\_hamiltonian()}\spxextra{qcompute\_qapp.application.optimization.MaxCut method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.application.optimization:qcompute_qapp.application.optimization.MaxCut.graph_to_hamiltonian}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{graph\_to\_hamiltonian}}}{\emph{\DUrole{n}{graph}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Graph}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Constructs Hamiltonian from the target graph of the Max Cut problem
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{graph}} (\sphinxstyleliteralemphasis{\sphinxupquote{nx.Graph}}) \textendash{} Undirected graph without weights

\end{description}\end{quote}

\end{fulllineitems}

\index{decode\_bitstring() (qcompute\_qapp.application.optimization.MaxCut method)@\spxentry{decode\_bitstring()}\spxextra{qcompute\_qapp.application.optimization.MaxCut method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.application.optimization:qcompute_qapp.application.optimization.MaxCut.decode_bitstring}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{decode\_bitstring}}}{\emph{\DUrole{n}{bitstring}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}}}{{ $\rightarrow$ dict}}
\pysigstopsignatures
\sphinxAtStartPar
Decodes the measurement result into problem solution, i.e., set partition
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bitstring}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Measurement result with the largest probability

\sphinxlineitem{Returns}
\sphinxAtStartPar
Solution to the Max Cut problem

\sphinxlineitem{Return type}
\sphinxAtStartPar
dict

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\section{\sphinxstyleliteralintitle{\sphinxupquote{qcompute\_qapp.circuit}}}
\label{\detokenize{qcompute_qapp.circuit:module-qcompute_qapp.circuit}}\label{\detokenize{qcompute_qapp.circuit:qcompute-qapp-circuit}}\label{\detokenize{qcompute_qapp.circuit::doc}}\index{module@\spxentry{module}!qcompute\_qapp.circuit@\spxentry{qcompute\_qapp.circuit}}\index{qcompute\_qapp.circuit@\spxentry{qcompute\_qapp.circuit}!module@\spxentry{module}}
\sphinxAtStartPar
The pre\sphinxhyphen{}defined quantum circuit
\index{BasicCircuit (class in qcompute\_qapp.circuit)@\spxentry{BasicCircuit}\spxextra{class in qcompute\_qapp.circuit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.BasicCircuit}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{qcompute\_qapp.circuit.}}\sphinxbfcode{\sphinxupquote{BasicCircuit}}}{\emph{\DUrole{n}{num}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{ABC}}

\sphinxAtStartPar
Basic Circuit class

\sphinxAtStartPar
The constructor of the BasicCircuit class
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{num}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of qubits

\end{description}\end{quote}
\index{add\_circuit() (qcompute\_qapp.circuit.BasicCircuit method)@\spxentry{add\_circuit()}\spxextra{qcompute\_qapp.circuit.BasicCircuit method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.BasicCircuit.add_circuit}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract\DUrole{w}{  }}}\sphinxbfcode{\sphinxupquote{add\_circuit}}}{\emph{\DUrole{n}{q}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{QRegPool}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Adds circuit to the register.
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{q}} (\sphinxstyleliteralemphasis{\sphinxupquote{QRegPool}}) \textendash{} Quantum register to which this circuit is added

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{IQPEncodingCircuit (class in qcompute\_qapp.circuit)@\spxentry{IQPEncodingCircuit}\spxextra{class in qcompute\_qapp.circuit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.IQPEncodingCircuit}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{qcompute\_qapp.circuit.}}\sphinxbfcode{\sphinxupquote{IQPEncodingCircuit}}}{\emph{\DUrole{n}{num}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{inverse}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{bool}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{False}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.BasicCircuit}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{BasicCircuit}}}}}

\sphinxAtStartPar
IQP Encoding Circuit class

\sphinxAtStartPar
The constructor of the IQPEncodingCircuit class
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{num}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of qubits

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{inverse}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Whether the encoding circuit will be inverted, i.e. U\textasciicircum{}dagger(x) if True, defaults to False

\end{itemize}

\end{description}\end{quote}
\index{add\_circuit() (qcompute\_qapp.circuit.IQPEncodingCircuit method)@\spxentry{add\_circuit()}\spxextra{qcompute\_qapp.circuit.IQPEncodingCircuit method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.IQPEncodingCircuit.add_circuit}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_circuit}}}{\emph{\DUrole{n}{q}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{QRegPool}}, \emph{\DUrole{n}{x}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{ndarray}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Adds the encoding circuit used to map a classical data vector into its quantum feature state
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{q}} (\sphinxstyleliteralemphasis{\sphinxupquote{QRegPool}}) \textendash{} Quantum register to which this circuit is added

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Classical data vector to be encoded

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{BasisEncodingCircuit (class in qcompute\_qapp.circuit)@\spxentry{BasisEncodingCircuit}\spxextra{class in qcompute\_qapp.circuit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.BasisEncodingCircuit}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{qcompute\_qapp.circuit.}}\sphinxbfcode{\sphinxupquote{BasisEncodingCircuit}}}{\emph{\DUrole{n}{num}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{bit\_string}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.BasicCircuit}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{BasicCircuit}}}}}

\sphinxAtStartPar
Basis Encoding Circuit class

\sphinxAtStartPar
The constructor of the BasisEncodingCircuit class
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{num}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of qubits

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{bit\_string}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Bit string to be encoded as a quantum state

\end{itemize}

\end{description}\end{quote}
\index{add\_circuit() (qcompute\_qapp.circuit.BasisEncodingCircuit method)@\spxentry{add\_circuit()}\spxextra{qcompute\_qapp.circuit.BasisEncodingCircuit method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.BasisEncodingCircuit.add_circuit}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_circuit}}}{\emph{\DUrole{n}{q}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{QRegPool}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Adds the basis encoding circuit to the register
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{q}} (\sphinxstyleliteralemphasis{\sphinxupquote{QRegPool}}) \textendash{} Quantum register to which this circuit is added

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{KernelEstimationCircuit (class in qcompute\_qapp.circuit)@\spxentry{KernelEstimationCircuit}\spxextra{class in qcompute\_qapp.circuit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.KernelEstimationCircuit}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{qcompute\_qapp.circuit.}}\sphinxbfcode{\sphinxupquote{KernelEstimationCircuit}}}{\emph{\DUrole{n}{num}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{encoding\_style}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.BasicCircuit}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{BasicCircuit}}}}}

\sphinxAtStartPar
Kernel Estimation Circuit class

\sphinxAtStartPar
The constructor of the KernelEstimationCircuit class
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{num}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of qubits

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{encoding\_style}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Encoding circuit, only accepts \sphinxcode{\sphinxupquote{\textquotesingle{}IQP\textquotesingle{}}} for now

\end{itemize}

\end{description}\end{quote}
\index{add\_circuit() (qcompute\_qapp.circuit.KernelEstimationCircuit method)@\spxentry{add\_circuit()}\spxextra{qcompute\_qapp.circuit.KernelEstimationCircuit method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.KernelEstimationCircuit.add_circuit}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_circuit}}}{\emph{\DUrole{n}{q}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{QRegPool}}, \emph{\DUrole{n}{x1}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{ndarray}}, \emph{\DUrole{n}{x2}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{ndarray}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Adds the kernel estimation circuit used to evaluate the kernel entry value between
two classical data vectors
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{q}} (\sphinxstyleliteralemphasis{\sphinxupquote{QRegPool}}) \textendash{} Quantum register to which this circuit is added

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x1}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} First classical vector

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{x2}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Second classical vector

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ParameterizedCircuit (class in qcompute\_qapp.circuit)@\spxentry{ParameterizedCircuit}\spxextra{class in qcompute\_qapp.circuit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.ParameterizedCircuit}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{qcompute\_qapp.circuit.}}\sphinxbfcode{\sphinxupquote{ParameterizedCircuit}}}{\emph{\DUrole{n}{num}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{parameters}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{ndarray}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.BasicCircuit}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{BasicCircuit}}}}}

\sphinxAtStartPar
Parameterized Circuit class

\sphinxAtStartPar
The constructor of the BasicCircuit class
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{num}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of qubits

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parameters}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Parameters of parameterized gates

\end{itemize}

\end{description}\end{quote}
\index{parameters (qcompute\_qapp.circuit.ParameterizedCircuit property)@\spxentry{parameters}\spxextra{qcompute\_qapp.circuit.ParameterizedCircuit property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.ParameterizedCircuit.parameters}}
\pysigstartsignatures
\pysigline{\sphinxbfcode{\sphinxupquote{property\DUrole{w}{  }}}\sphinxbfcode{\sphinxupquote{parameters}}\sphinxbfcode{\sphinxupquote{\DUrole{p}{:}\DUrole{w}{  }ndarray}}}
\pysigstopsignatures
\sphinxAtStartPar
Parameters of the circuit
\begin{quote}\begin{description}
\sphinxlineitem{Returns}
\sphinxAtStartPar
Parameters of the circuit

\sphinxlineitem{Return type}
\sphinxAtStartPar
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}

\index{set\_parameters() (qcompute\_qapp.circuit.ParameterizedCircuit method)@\spxentry{set\_parameters()}\spxextra{qcompute\_qapp.circuit.ParameterizedCircuit method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.ParameterizedCircuit.set_parameters}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_parameters}}}{\emph{\DUrole{n}{parameters}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{ndarray}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Sets parameters of the circuit
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parameters}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} New parameters of the circuit

\end{description}\end{quote}

\end{fulllineitems}

\index{add\_circuit() (qcompute\_qapp.circuit.ParameterizedCircuit method)@\spxentry{add\_circuit()}\spxextra{qcompute\_qapp.circuit.ParameterizedCircuit method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.ParameterizedCircuit.add_circuit}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract\DUrole{w}{  }}}\sphinxbfcode{\sphinxupquote{add\_circuit}}}{\emph{\DUrole{n}{q}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{QRegPool}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Adds the circuit to the register
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{q}} (\sphinxstyleliteralemphasis{\sphinxupquote{QRegPool}}) \textendash{} Quantum register to which this circuit is added

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{PauliMeasurementCircuit (class in qcompute\_qapp.circuit)@\spxentry{PauliMeasurementCircuit}\spxextra{class in qcompute\_qapp.circuit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.PauliMeasurementCircuit}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{qcompute\_qapp.circuit.}}\sphinxbfcode{\sphinxupquote{PauliMeasurementCircuit}}}{\emph{\DUrole{n}{num}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{pauli\_terms}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.BasicCircuit}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{BasicCircuit}}}}}

\sphinxAtStartPar
Pauli Measurement Circuit class

\sphinxAtStartPar
The constructor of the PauliMeasurementCircuit class
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{num}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of qubits

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pauli\_terms}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Pauli terms to be measured

\end{itemize}

\end{description}\end{quote}
\index{add\_circuit() (qcompute\_qapp.circuit.PauliMeasurementCircuit method)@\spxentry{add\_circuit()}\spxextra{qcompute\_qapp.circuit.PauliMeasurementCircuit method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.PauliMeasurementCircuit.add_circuit}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_circuit}}}{\emph{\DUrole{n}{q}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{QRegPool}}, \emph{\DUrole{n}{pauli\_str}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Adds the pauli measurement circuit to the register
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{q}} (\sphinxstyleliteralemphasis{\sphinxupquote{QRegPool}}) \textendash{} Quantum register to which this circuit is added

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pauli\_str}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Pauli string to be measured

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_expectation() (qcompute\_qapp.circuit.PauliMeasurementCircuit method)@\spxentry{get\_expectation()}\spxextra{qcompute\_qapp.circuit.PauliMeasurementCircuit method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.PauliMeasurementCircuit.get_expectation}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_expectation}}}{\emph{\DUrole{n}{preceding\_circuits}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{List\DUrole{p}{{[}}{\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.BasicCircuit}]{\sphinxcrossref{BasicCircuit}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{shots}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{backend}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}}}{{ $\rightarrow$ float}}
\pysigstopsignatures
\sphinxAtStartPar
Computes the expectation value of the Pauli terms
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{preceding\_circuits}} (\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}{\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.BasicCircuit}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{BasicCircuit}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Circuit precedes the measurement circuit

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shots}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of measurement shots

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{backend}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Backend to be used in this task

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Expectation value of the Pauli terms

\sphinxlineitem{Return type}
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{PauliMeasurementCircuitWithAncilla (class in qcompute\_qapp.circuit)@\spxentry{PauliMeasurementCircuitWithAncilla}\spxextra{class in qcompute\_qapp.circuit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.PauliMeasurementCircuitWithAncilla}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{qcompute\_qapp.circuit.}}\sphinxbfcode{\sphinxupquote{PauliMeasurementCircuitWithAncilla}}}{\emph{\DUrole{n}{num}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{pauli\_terms}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.BasicCircuit}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{BasicCircuit}}}}}

\sphinxAtStartPar
Pauli Measurement Circuit with Ancilla class

\sphinxAtStartPar
The constructor of the PauliMeasurementCircuitWithAncilla class
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{num}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of qubits

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pauli\_terms}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Pauli terms to be measured

\end{itemize}

\end{description}\end{quote}
\index{add\_circuit() (qcompute\_qapp.circuit.PauliMeasurementCircuitWithAncilla method)@\spxentry{add\_circuit()}\spxextra{qcompute\_qapp.circuit.PauliMeasurementCircuitWithAncilla method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.PauliMeasurementCircuitWithAncilla.add_circuit}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_circuit}}}{\emph{\DUrole{n}{q}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{QRegPool}}, \emph{\DUrole{n}{pauli\_str}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Adds the pauli measurement circuit to the register
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{q}} (\sphinxstyleliteralemphasis{\sphinxupquote{QRegPool}}) \textendash{} Quantum register to which this circuit is added

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pauli\_str}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Pauli string to be measured

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_expectation() (qcompute\_qapp.circuit.PauliMeasurementCircuitWithAncilla method)@\spxentry{get\_expectation()}\spxextra{qcompute\_qapp.circuit.PauliMeasurementCircuitWithAncilla method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.PauliMeasurementCircuitWithAncilla.get_expectation}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_expectation}}}{\emph{\DUrole{n}{preceding\_circuits}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{List\DUrole{p}{{[}}{\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.BasicCircuit}]{\sphinxcrossref{BasicCircuit}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{shots}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{backend}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}}}{{ $\rightarrow$ float}}
\pysigstopsignatures
\sphinxAtStartPar
Computes the expectation value of the Pauli terms
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{preceding\_circuits}} (\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}{\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.BasicCircuit}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{BasicCircuit}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Circuit precedes the measurement circuit

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shots}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of measurement shots

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{backend}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Backend to be used in this task

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Expectation value of the Pauli terms

\sphinxlineitem{Return type}
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{SimultaneousPauliMeasurementCircuit (class in qcompute\_qapp.circuit)@\spxentry{SimultaneousPauliMeasurementCircuit}\spxextra{class in qcompute\_qapp.circuit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.SimultaneousPauliMeasurementCircuit}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{qcompute\_qapp.circuit.}}\sphinxbfcode{\sphinxupquote{SimultaneousPauliMeasurementCircuit}}}{\emph{\DUrole{n}{num}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{pauli\_terms}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{list}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.BasicCircuit}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{BasicCircuit}}}}}

\sphinxAtStartPar
Simultaneous Pauli Measurement Circuit for Qubitwise Commute Pauli Terms

\sphinxAtStartPar
The constructor of the SimultaneousPauliMeasurementCircuit class
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{num}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of qubits

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pauli\_terms}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} Pauli terms to be measured

\end{itemize}

\end{description}\end{quote}
\index{add\_circuit() (qcompute\_qapp.circuit.SimultaneousPauliMeasurementCircuit method)@\spxentry{add\_circuit()}\spxextra{qcompute\_qapp.circuit.SimultaneousPauliMeasurementCircuit method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.SimultaneousPauliMeasurementCircuit.add_circuit}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_circuit}}}{\emph{\DUrole{n}{q}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{QRegPool}}, \emph{\DUrole{n}{clique}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{list}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Adds the simultaneous pauli measurement circuit to the register
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{q}} (\sphinxstyleliteralemphasis{\sphinxupquote{QRegPool}}) \textendash{} Quantum register to which this circuit is added

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{clique}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} Clique of Pauli terms to be measured together

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_expectation() (qcompute\_qapp.circuit.SimultaneousPauliMeasurementCircuit method)@\spxentry{get\_expectation()}\spxextra{qcompute\_qapp.circuit.SimultaneousPauliMeasurementCircuit method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.SimultaneousPauliMeasurementCircuit.get_expectation}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_expectation}}}{\emph{\DUrole{n}{preceding\_circuits}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{List\DUrole{p}{{[}}{\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.BasicCircuit}]{\sphinxcrossref{BasicCircuit}}}\DUrole{p}{{]}}}}, \emph{\DUrole{n}{shots}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{backend}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}}}{{ $\rightarrow$ float}}
\pysigstopsignatures
\sphinxAtStartPar
Computes the expectation value of the Pauli terms
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{preceding\_circuits}} (\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}{\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.BasicCircuit}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{BasicCircuit}}}}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Circuit precedes the measurement circuit

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shots}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of measurement shots

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{backend}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Backend to be used in this task

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
Expectation value of the Pauli terms

\sphinxlineitem{Return type}
\sphinxAtStartPar
float

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{QAOAAnsatz (class in qcompute\_qapp.circuit)@\spxentry{QAOAAnsatz}\spxextra{class in qcompute\_qapp.circuit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.QAOAAnsatz}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{qcompute\_qapp.circuit.}}\sphinxbfcode{\sphinxupquote{QAOAAnsatz}}}{\emph{\DUrole{n}{num}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{parameters}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{ndarray}}, \emph{\DUrole{n}{hamiltonian}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{list}}, \emph{\DUrole{n}{layer}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.ParameterizedCircuit}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ParameterizedCircuit}}}}}

\sphinxAtStartPar
QAOA Ansatz class

\sphinxAtStartPar
The constructor of the QAOAAnsatz class
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{num}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of qubits in this ansatz

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parameters}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Parameters of parameterized gates in this ansatz

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hamiltonian}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} Hamiltonian used to construct the QAOA ansatz

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{layer}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of layers for this Ansatz

\end{itemize}

\end{description}\end{quote}
\index{add\_circuit() (qcompute\_qapp.circuit.QAOAAnsatz method)@\spxentry{add\_circuit()}\spxextra{qcompute\_qapp.circuit.QAOAAnsatz method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.QAOAAnsatz.add_circuit}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_circuit}}}{\emph{\DUrole{n}{q}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{QRegPool}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Adds circuit to the register according to the given hamiltonian
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{q}} (\sphinxstyleliteralemphasis{\sphinxupquote{QRegPool}}) \textendash{} Quantum register to which this circuit is added

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{UniversalCircuit (class in qcompute\_qapp.circuit)@\spxentry{UniversalCircuit}\spxextra{class in qcompute\_qapp.circuit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.UniversalCircuit}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{qcompute\_qapp.circuit.}}\sphinxbfcode{\sphinxupquote{UniversalCircuit}}}{\emph{\DUrole{n}{num}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{parameters}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{ndarray}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.ParameterizedCircuit}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ParameterizedCircuit}}}}}

\sphinxAtStartPar
Universal Circuit class

\sphinxAtStartPar
The constructor of the UniversalCircuit class
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{num}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of qubits in this ansatz

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parameters}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Parameters of parameterized gates in this circuit, whose shape should be \sphinxcode{\sphinxupquote{(3,)}}
for single\sphinxhyphen{}qubit cases and should be \sphinxcode{\sphinxupquote{(15,)}} for 2\sphinxhyphen{}qubit cases

\end{itemize}

\end{description}\end{quote}
\index{add\_circuit() (qcompute\_qapp.circuit.UniversalCircuit method)@\spxentry{add\_circuit()}\spxextra{qcompute\_qapp.circuit.UniversalCircuit method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.UniversalCircuit.add_circuit}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_circuit}}}{\emph{\DUrole{n}{q}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{QRegPool}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Adds the universal circuit to the register. Only support single\sphinxhyphen{}qubit and 2\sphinxhyphen{}qubit cases
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{q}} (\sphinxstyleliteralemphasis{\sphinxupquote{QRegPool}}) \textendash{} Quantum register to which this circuit is added

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{RealEntangledCircuit (class in qcompute\_qapp.circuit)@\spxentry{RealEntangledCircuit}\spxextra{class in qcompute\_qapp.circuit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.RealEntangledCircuit}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{qcompute\_qapp.circuit.}}\sphinxbfcode{\sphinxupquote{RealEntangledCircuit}}}{\emph{\DUrole{n}{num}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{layer}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{parameters}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{ndarray}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.ParameterizedCircuit}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ParameterizedCircuit}}}}}

\sphinxAtStartPar
Real Entangled Circuit class

\sphinxAtStartPar
The constructor of the RealEntangledCircuit class
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{num}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of qubits in this ansatz

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{layer}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of layers for this ansatz

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parameters}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Parameters of parameterized gates in this circuit, whose shape
should be \sphinxcode{\sphinxupquote{(num * layer,)}}

\end{itemize}

\end{description}\end{quote}
\index{add\_circuit() (qcompute\_qapp.circuit.RealEntangledCircuit method)@\spxentry{add\_circuit()}\spxextra{qcompute\_qapp.circuit.RealEntangledCircuit method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.RealEntangledCircuit.add_circuit}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_circuit}}}{\emph{\DUrole{n}{q}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{QRegPool}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Adds the real entangled circuit to the register
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{q}} (\sphinxstyleliteralemphasis{\sphinxupquote{QRegPool}}) \textendash{} Quantum register to which this circuit is added

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ComplexEntangledCircuit (class in qcompute\_qapp.circuit)@\spxentry{ComplexEntangledCircuit}\spxextra{class in qcompute\_qapp.circuit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.ComplexEntangledCircuit}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{qcompute\_qapp.circuit.}}\sphinxbfcode{\sphinxupquote{ComplexEntangledCircuit}}}{\emph{\DUrole{n}{num}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{layer}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{parameters}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{ndarray}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.ParameterizedCircuit}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ParameterizedCircuit}}}}}

\sphinxAtStartPar
Complex Entangled Circuit class

\sphinxAtStartPar
The constructor of the ComplexEntangledCircuit class
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{num}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of qubits in this Ansatz

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{layer}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of layer for this Ansatz

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parameters}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Parameters of parameterized gates in this circuit, whose shape
should be \sphinxcode{\sphinxupquote{(num * layer * 2,)}}

\end{itemize}

\end{description}\end{quote}
\index{add\_circuit() (qcompute\_qapp.circuit.ComplexEntangledCircuit method)@\spxentry{add\_circuit()}\spxextra{qcompute\_qapp.circuit.ComplexEntangledCircuit method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.ComplexEntangledCircuit.add_circuit}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_circuit}}}{\emph{\DUrole{n}{q}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{QRegPool}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Adds the complex entangled circuit to the register
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{q}} (\sphinxstyleliteralemphasis{\sphinxupquote{QRegPool}}) \textendash{} Quantum register to which this circuit is added

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{RealAlternatingLayeredCircuit (class in qcompute\_qapp.circuit)@\spxentry{RealAlternatingLayeredCircuit}\spxextra{class in qcompute\_qapp.circuit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.RealAlternatingLayeredCircuit}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{qcompute\_qapp.circuit.}}\sphinxbfcode{\sphinxupquote{RealAlternatingLayeredCircuit}}}{\emph{\DUrole{n}{num}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{layer}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{parameters}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{ndarray}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.ParameterizedCircuit}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ParameterizedCircuit}}}}}

\sphinxAtStartPar
Real Alternating Layered Circuit class

\sphinxAtStartPar
The constructor of the RealAlternatingLayeredCircuit class
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{num}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of qubits in this Ansatz

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{layer}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of layer for this Ansatz

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parameters}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Parameters of parameterized gates in this circuit, whose shape
should be \sphinxcode{\sphinxupquote{((2 * num \sphinxhyphen{} 2) * layer,)}}

\end{itemize}

\end{description}\end{quote}
\index{add\_circuit() (qcompute\_qapp.circuit.RealAlternatingLayeredCircuit method)@\spxentry{add\_circuit()}\spxextra{qcompute\_qapp.circuit.RealAlternatingLayeredCircuit method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.RealAlternatingLayeredCircuit.add_circuit}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_circuit}}}{\emph{\DUrole{n}{q}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{QRegPool}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Adds the real alternating layered circuit to the register
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{q}} (\sphinxstyleliteralemphasis{\sphinxupquote{QRegPool}}) \textendash{} Quantum register to which this circuit is added

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{ComplexAlternatingLayeredCircuit (class in qcompute\_qapp.circuit)@\spxentry{ComplexAlternatingLayeredCircuit}\spxextra{class in qcompute\_qapp.circuit}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.ComplexAlternatingLayeredCircuit}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{qcompute\_qapp.circuit.}}\sphinxbfcode{\sphinxupquote{ComplexAlternatingLayeredCircuit}}}{\emph{\DUrole{n}{num}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{layer}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{parameters}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{ndarray}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.ParameterizedCircuit}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ParameterizedCircuit}}}}}

\sphinxAtStartPar
Complex Alternating Layered Circuit class

\sphinxAtStartPar
The constructor of the ComplexAlternatingLayeredCircuit class
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{num}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of qubits in this Ansatz

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{layer}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of layer for this Ansatz

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{parameters}} (\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}) \textendash{} Parameters of parameterized gates in this circuit, whose shape
should be \sphinxcode{\sphinxupquote{((4 * num \sphinxhyphen{} 4) * layer,)}}

\end{itemize}

\end{description}\end{quote}
\index{add\_circuit() (qcompute\_qapp.circuit.ComplexAlternatingLayeredCircuit method)@\spxentry{add\_circuit()}\spxextra{qcompute\_qapp.circuit.ComplexAlternatingLayeredCircuit method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.ComplexAlternatingLayeredCircuit.add_circuit}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{add\_circuit}}}{\emph{\DUrole{n}{q}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{QRegPool}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Adds the complex alternating layered circuit to the register
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{q}} (\sphinxstyleliteralemphasis{\sphinxupquote{QRegPool}}) \textendash{} Quantum register to which this circuit is added

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\section{\sphinxstyleliteralintitle{\sphinxupquote{qcompute\_qapp.optimizer}}}
\label{\detokenize{qcompute_qapp.optimizer:module-qcompute_qapp.optimizer}}\label{\detokenize{qcompute_qapp.optimizer:qcompute-qapp-optimizer}}\label{\detokenize{qcompute_qapp.optimizer::doc}}\index{module@\spxentry{module}!qcompute\_qapp.optimizer@\spxentry{qcompute\_qapp.optimizer}}\index{qcompute\_qapp.optimizer@\spxentry{qcompute\_qapp.optimizer}!module@\spxentry{module}}
\sphinxAtStartPar
The provided optimizer
\index{BasicOptimizer (class in qcompute\_qapp.optimizer)@\spxentry{BasicOptimizer}\spxextra{class in qcompute\_qapp.optimizer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.optimizer:qcompute_qapp.optimizer.BasicOptimizer}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{qcompute\_qapp.optimizer.}}\sphinxbfcode{\sphinxupquote{BasicOptimizer}}}{\emph{\DUrole{n}{iterations}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{circuit}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.ParameterizedCircuit}]{\sphinxcrossref{ParameterizedCircuit}}}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: \sphinxcode{\sphinxupquote{ABC}}

\sphinxAtStartPar
Basic Optimizer class

\sphinxAtStartPar
The constructor of the BasicOptimizer class
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{iterations}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of iterations

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{circuit}} ({\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.ParameterizedCircuit}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{ParameterizedCircuit}}}}}) \textendash{} Circuit whose parameters are to be optimized

\end{itemize}

\end{description}\end{quote}
\index{set\_circuit() (qcompute\_qapp.optimizer.BasicOptimizer method)@\spxentry{set\_circuit()}\spxextra{qcompute\_qapp.optimizer.BasicOptimizer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.optimizer:qcompute_qapp.optimizer.BasicOptimizer.set_circuit}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{set\_circuit}}}{\emph{\DUrole{n}{circuit}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.ParameterizedCircuit}]{\sphinxcrossref{ParameterizedCircuit}}}}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Sets the parameterized circuit to be optimized
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{circuit}} ({\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.ParameterizedCircuit}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{ParameterizedCircuit}}}}}) \textendash{} Parameterized Circuit to be optimized

\end{description}\end{quote}

\end{fulllineitems}

\index{minimize() (qcompute\_qapp.optimizer.BasicOptimizer method)@\spxentry{minimize()}\spxextra{qcompute\_qapp.optimizer.BasicOptimizer method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.optimizer:qcompute_qapp.optimizer.BasicOptimizer.minimize}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{abstract\DUrole{w}{  }}}\sphinxbfcode{\sphinxupquote{minimize}}}{\emph{\DUrole{n}{shots}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{loss\_func}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Callable\DUrole{p}{{[}}\DUrole{p}{{[}}ndarray\DUrole{p}{,}\DUrole{w}{  }int\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }float\DUrole{p}{{]}}}}, \emph{\DUrole{n}{grad\_func}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Callable\DUrole{p}{{[}}\DUrole{p}{{[}}ndarray\DUrole{p}{,}\DUrole{w}{  }int\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }ndarray\DUrole{p}{{]}}}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Minimizes the given loss function
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shots}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of measurement shots

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{loss\_func}} (\sphinxstyleliteralemphasis{\sphinxupquote{Callable}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Loss function to be minimized

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{grad\_func}} (\sphinxstyleliteralemphasis{\sphinxupquote{Callable}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Function for calculating gradients

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{SGD (class in qcompute\_qapp.optimizer)@\spxentry{SGD}\spxextra{class in qcompute\_qapp.optimizer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.optimizer:qcompute_qapp.optimizer.SGD}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{qcompute\_qapp.optimizer.}}\sphinxbfcode{\sphinxupquote{SGD}}}{\emph{\DUrole{n}{iterations}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{circuit}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.BasicCircuit}]{\sphinxcrossref{BasicCircuit}}}}}, \emph{\DUrole{n}{learning\_rate}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{float}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{qcompute_qapp.optimizer:qcompute_qapp.optimizer.BasicOptimizer}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{BasicOptimizer}}}}}

\sphinxAtStartPar
SGD Optimizer class

\sphinxAtStartPar
The constructor of the SGD class
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{iterations}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of iterations

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{circuit}} ({\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.BasicCircuit}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{BasicCircuit}}}}}) \textendash{} Circuit whose parameters are to be optimized

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{learning\_rate}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Learning rate

\end{itemize}

\end{description}\end{quote}
\index{minimize() (qcompute\_qapp.optimizer.SGD method)@\spxentry{minimize()}\spxextra{qcompute\_qapp.optimizer.SGD method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.optimizer:qcompute_qapp.optimizer.SGD.minimize}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{minimize}}}{\emph{\DUrole{n}{shots}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{loss\_func}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Callable\DUrole{p}{{[}}\DUrole{p}{{[}}ndarray\DUrole{p}{,}\DUrole{w}{  }int\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }float\DUrole{p}{{]}}}}, \emph{\DUrole{n}{grad\_func}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Callable\DUrole{p}{{[}}\DUrole{p}{{[}}ndarray\DUrole{p}{,}\DUrole{w}{  }int\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }ndarray\DUrole{p}{{]}}}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Minimizes the given loss function
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shots}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of measurement shots

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{loss\_func}} (\sphinxstyleliteralemphasis{\sphinxupquote{Callable}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Loss function to be minimized

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{grad\_func}} (\sphinxstyleliteralemphasis{\sphinxupquote{Callable}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Function for calculating gradients

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{SLSQP (class in qcompute\_qapp.optimizer)@\spxentry{SLSQP}\spxextra{class in qcompute\_qapp.optimizer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.optimizer:qcompute_qapp.optimizer.SLSQP}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{qcompute\_qapp.optimizer.}}\sphinxbfcode{\sphinxupquote{SLSQP}}}{\emph{\DUrole{n}{iterations}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{circuit}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.BasicCircuit}]{\sphinxcrossref{BasicCircuit}}}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{qcompute_qapp.optimizer:qcompute_qapp.optimizer.BasicOptimizer}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{BasicOptimizer}}}}}

\sphinxAtStartPar
SLSQP Optimizer class

\sphinxAtStartPar
The constructor of the SLSQP class
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{iterations}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of iterations

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{circuit}} ({\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.BasicCircuit}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{BasicCircuit}}}}}) \textendash{} Circuit whose parameters are to be optimized

\end{itemize}

\end{description}\end{quote}
\index{minimize() (qcompute\_qapp.optimizer.SLSQP method)@\spxentry{minimize()}\spxextra{qcompute\_qapp.optimizer.SLSQP method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.optimizer:qcompute_qapp.optimizer.SLSQP.minimize}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{minimize}}}{\emph{\DUrole{n}{shots}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{loss\_func}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Callable\DUrole{p}{{[}}\DUrole{p}{{[}}ndarray\DUrole{p}{,}\DUrole{w}{  }int\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }float\DUrole{p}{{]}}}}, \emph{\DUrole{n}{grad\_func}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Callable\DUrole{p}{{[}}\DUrole{p}{{[}}ndarray\DUrole{p}{,}\DUrole{w}{  }int\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }ndarray\DUrole{p}{{]}}}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Minimizes the given loss function
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shots}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of measurement shots

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{loss\_func}} (\sphinxstyleliteralemphasis{\sphinxupquote{Callable}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Loss function to be minimized

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{grad\_func}} (\sphinxstyleliteralemphasis{\sphinxupquote{Callable}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Function for calculating gradients

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{SPSA (class in qcompute\_qapp.optimizer)@\spxentry{SPSA}\spxextra{class in qcompute\_qapp.optimizer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.optimizer:qcompute_qapp.optimizer.SPSA}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{qcompute\_qapp.optimizer.}}\sphinxbfcode{\sphinxupquote{SPSA}}}{\emph{\DUrole{n}{iterations}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{circuit}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.BasicCircuit}]{\sphinxcrossref{BasicCircuit}}}}}, \emph{\DUrole{n}{a}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{float}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{1.0}}, \emph{\DUrole{n}{c}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{float}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{1.0}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{qcompute_qapp.optimizer:qcompute_qapp.optimizer.BasicOptimizer}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{BasicOptimizer}}}}}

\sphinxAtStartPar
SPSA Optimizer class

\sphinxAtStartPar
The constructor of the SPSA class
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{iterations}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of iterations

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{circuit}} ({\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.BasicCircuit}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{BasicCircuit}}}}}) \textendash{} Circuit whose parameters are to be optimized

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{a}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Scaling parameter for step size, defaults to 1.0

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{c}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Scaling parameter for evaluation step size, defaults to 1.0

\end{itemize}

\end{description}\end{quote}
\index{minimize() (qcompute\_qapp.optimizer.SPSA method)@\spxentry{minimize()}\spxextra{qcompute\_qapp.optimizer.SPSA method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.optimizer:qcompute_qapp.optimizer.SPSA.minimize}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{minimize}}}{\emph{\DUrole{n}{shots}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{loss\_func}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Callable\DUrole{p}{{[}}\DUrole{p}{{[}}ndarray\DUrole{p}{,}\DUrole{w}{  }int\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }float\DUrole{p}{{]}}}}, \emph{\DUrole{n}{grad\_func}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Callable\DUrole{p}{{[}}\DUrole{p}{{[}}ndarray\DUrole{p}{,}\DUrole{w}{  }int\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }ndarray\DUrole{p}{{]}}}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Minimizes the given loss function
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shots}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of measurement shots

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{loss\_func}} (\sphinxstyleliteralemphasis{\sphinxupquote{Callable}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Loss function to be minimized

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{grad\_func}} (\sphinxstyleliteralemphasis{\sphinxupquote{Callable}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Function for calculating gradients

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{SMO (class in qcompute\_qapp.optimizer)@\spxentry{SMO}\spxextra{class in qcompute\_qapp.optimizer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.optimizer:qcompute_qapp.optimizer.SMO}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{qcompute\_qapp.optimizer.}}\sphinxbfcode{\sphinxupquote{SMO}}}{\emph{\DUrole{n}{iterations}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{circuit}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.BasicCircuit}]{\sphinxcrossref{BasicCircuit}}}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{qcompute_qapp.optimizer:qcompute_qapp.optimizer.BasicOptimizer}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{BasicOptimizer}}}}}

\sphinxAtStartPar
SMO Optimizer class

\sphinxAtStartPar
Please see \sphinxurl{https://arxiv.org/abs/1903.12166} for details on this optimization method.

\sphinxAtStartPar
The constructor of the SMO class
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{iterations}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of iterations

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{circuit}} ({\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.BasicCircuit}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{BasicCircuit}}}}}) \textendash{} Circuit whose parameters are to be optimized

\end{itemize}

\end{description}\end{quote}
\index{minimize() (qcompute\_qapp.optimizer.SMO method)@\spxentry{minimize()}\spxextra{qcompute\_qapp.optimizer.SMO method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.optimizer:qcompute_qapp.optimizer.SMO.minimize}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{minimize}}}{\emph{\DUrole{n}{shots}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{loss\_func}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Callable\DUrole{p}{{[}}\DUrole{p}{{[}}ndarray\DUrole{p}{,}\DUrole{w}{  }int\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }float\DUrole{p}{{]}}}}, \emph{\DUrole{n}{grad\_func}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Callable\DUrole{p}{{[}}\DUrole{p}{{[}}ndarray\DUrole{p}{,}\DUrole{w}{  }int\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }ndarray\DUrole{p}{{]}}}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Minimizes the given loss function
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shots}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of measurement shots

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{loss\_func}} (\sphinxstyleliteralemphasis{\sphinxupquote{Callable}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Loss function to be minimized

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{grad\_func}} (\sphinxstyleliteralemphasis{\sphinxupquote{Callable}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Function for calculating gradients

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Powell (class in qcompute\_qapp.optimizer)@\spxentry{Powell}\spxextra{class in qcompute\_qapp.optimizer}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.optimizer:qcompute_qapp.optimizer.Powell}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class\DUrole{w}{  }}}\sphinxcode{\sphinxupquote{qcompute\_qapp.optimizer.}}\sphinxbfcode{\sphinxupquote{Powell}}}{\emph{\DUrole{n}{iterations}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{circuit}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{{\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.BasicCircuit}]{\sphinxcrossref{BasicCircuit}}}}}}{}
\pysigstopsignatures
\sphinxAtStartPar
Bases: {\hyperref[\detokenize{qcompute_qapp.optimizer:qcompute_qapp.optimizer.BasicOptimizer}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{BasicOptimizer}}}}}

\sphinxAtStartPar
Powell Optimizer class

\sphinxAtStartPar
The constructor of the Powell class
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{iterations}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of iterations

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{circuit}} ({\hyperref[\detokenize{qcompute_qapp.circuit:qcompute_qapp.circuit.BasicCircuit}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{BasicCircuit}}}}}) \textendash{} Circuit whose parameters are to be optimized

\end{itemize}

\end{description}\end{quote}
\index{minimize() (qcompute\_qapp.optimizer.Powell method)@\spxentry{minimize()}\spxextra{qcompute\_qapp.optimizer.Powell method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.optimizer:qcompute_qapp.optimizer.Powell.minimize}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{minimize}}}{\emph{\DUrole{n}{shots}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{int}}, \emph{\DUrole{n}{loss\_func}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Callable\DUrole{p}{{[}}\DUrole{p}{{[}}ndarray\DUrole{p}{,}\DUrole{w}{  }int\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }float\DUrole{p}{{]}}}}, \emph{\DUrole{n}{grad\_func}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{Callable\DUrole{p}{{[}}\DUrole{p}{{[}}ndarray\DUrole{p}{,}\DUrole{w}{  }int\DUrole{p}{{]}}\DUrole{p}{,}\DUrole{w}{  }ndarray\DUrole{p}{{]}}}}}{{ $\rightarrow$ None}}
\pysigstopsignatures
\sphinxAtStartPar
Minimizes the given loss function
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{shots}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of measurement shots

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{loss\_func}} (\sphinxstyleliteralemphasis{\sphinxupquote{Callable}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}) \textendash{} Loss function to be minimized

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{grad\_func}} (\sphinxstyleliteralemphasis{\sphinxupquote{Callable}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{{[}}}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{np.ndarray}}\sphinxstyleliteralemphasis{\sphinxupquote{{]}}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} Function for calculating gradients

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}


\sphinxstepscope


\section{\sphinxstyleliteralintitle{\sphinxupquote{qcompute\_qapp.utils}}}
\label{\detokenize{qcompute_qapp.utils:module-qcompute_qapp.utils}}\label{\detokenize{qcompute_qapp.utils:qcompute-qapp-utils}}\label{\detokenize{qcompute_qapp.utils::doc}}\index{module@\spxentry{module}!qcompute\_qapp.utils@\spxentry{qcompute\_qapp.utils}}\index{qcompute\_qapp.utils@\spxentry{qcompute\_qapp.utils}!module@\spxentry{module}}
\sphinxAtStartPar
Some auxiliary functions
\index{grouping\_hamiltonian() (in module qcompute\_qapp.utils)@\spxentry{grouping\_hamiltonian()}\spxextra{in module qcompute\_qapp.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.utils:qcompute_qapp.utils.grouping_hamiltonian}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{qcompute\_qapp.utils.}}\sphinxbfcode{\sphinxupquote{grouping\_hamiltonian}}}{\emph{\DUrole{n}{hamiltonian}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{list}}, \emph{\DUrole{n}{coloring\_strategy}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{str}\DUrole{w}{  }\DUrole{o}{=}\DUrole{w}{  }\DUrole{default_value}{\textquotesingle{}largest\_first\textquotesingle{}}}}{{ $\rightarrow$ List\DUrole{p}{{[}}List\DUrole{p}{{[}}str\DUrole{p}{{]}}\DUrole{p}{{]}}}}
\pysigstopsignatures
\sphinxAtStartPar
Finds the minimum clique cover of the Hamiltonian graph, which is used for simultaneous Pauli measurement
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{hamiltonian}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} Hamiltonian of the target system

\item {} 
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{coloring\_strategy}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Graph coloring strategy chosen from the following: ‘largest\_first’, ‘random\_sequential’,
‘smallest\_last’, ‘independent\_set’, ‘connected\_sequential\_bfs’, ‘connected\_sequential\_dfs’, ‘connected\_sequential’,
‘saturation\_largest\_first’, and ‘DSATUR’; defaults to ‘largest\_first’

\end{itemize}

\sphinxlineitem{Returns}
\sphinxAtStartPar
List of cliques consisting of Pauli strings to be measured together

\sphinxlineitem{Return type}
\sphinxAtStartPar
List{[}List{[}str{]}{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{pauli\_terms\_to\_matrix() (in module qcompute\_qapp.utils)@\spxentry{pauli\_terms\_to\_matrix()}\spxextra{in module qcompute\_qapp.utils}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{qcompute_qapp.utils:qcompute_qapp.utils.pauli_terms_to_matrix}}
\pysigstartsignatures
\pysiglinewithargsret{\sphinxcode{\sphinxupquote{qcompute\_qapp.utils.}}\sphinxbfcode{\sphinxupquote{pauli\_terms\_to\_matrix}}}{\emph{\DUrole{n}{pauli\_terms}\DUrole{p}{:}\DUrole{w}{  }\DUrole{n}{list}}}{{ $\rightarrow$ ndarray}}
\pysigstopsignatures
\sphinxAtStartPar
Converts Pauli terms to a matrix
\begin{quote}\begin{description}
\sphinxlineitem{Parameters}
\sphinxAtStartPar
\sphinxstyleliteralstrong{\sphinxupquote{pauli\_terms}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} Pauli terms whose matrix is to be computed

\sphinxlineitem{Returns}
\sphinxAtStartPar
Matrix form of the Pauli terms

\sphinxlineitem{Return type}
\sphinxAtStartPar
np.ndarray

\end{description}\end{quote}

\end{fulllineitems}



\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{q}
\item\relax\sphinxstyleindexentry{qcompute\_qapp.algorithm}\sphinxstyleindexpageref{qcompute_qapp.algorithm:\detokenize{module-qcompute_qapp.algorithm}}
\item\relax\sphinxstyleindexentry{qcompute\_qapp.application.chemistry}\sphinxstyleindexpageref{qcompute_qapp.application.chemistry:\detokenize{module-qcompute_qapp.application.chemistry}}
\item\relax\sphinxstyleindexentry{qcompute\_qapp.application.optimization}\sphinxstyleindexpageref{qcompute_qapp.application.optimization:\detokenize{module-qcompute_qapp.application.optimization}}
\item\relax\sphinxstyleindexentry{qcompute\_qapp.circuit}\sphinxstyleindexpageref{qcompute_qapp.circuit:\detokenize{module-qcompute_qapp.circuit}}
\item\relax\sphinxstyleindexentry{qcompute\_qapp.optimizer}\sphinxstyleindexpageref{qcompute_qapp.optimizer:\detokenize{module-qcompute_qapp.optimizer}}
\item\relax\sphinxstyleindexentry{qcompute\_qapp.utils}\sphinxstyleindexpageref{qcompute_qapp.utils:\detokenize{module-qcompute_qapp.utils}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}