#!/usr/bin/python3
# -*- coding: utf-8 -*-
#
# Copyright (c) 2022 Baidu, Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

r"""
An example of Simon's algorithm.
"""

import numpy
from functools import reduce
from Extensions.QuantumNetwork.qcompute_qnet.quantum.circuit import Circuit

# Set the secret string in the function
secret_string = "111"
# The length of the secret bit string
n = len(secret_string)
# The number of qubits
qubit_num = 2 * n

# Create a quantum circuit
cir = Circuit("Simon's algorithm")

# Apply Hadamard gates to the first n qubits
for i in range(n):
    cir.h(i)

# Implement the quantum oracle for the secret string
for i in range(n):
    cir.cx([i, i + n])
# Check whether the function is one-to-one map
if "1" in secret_string:
    # Find the index of the first non-zero bit in the secret string
    index = secret_string.find("1")
    for i in range(n):
        if secret_string[i] == "1":
            cir.cx([index, i + n])

# Apply another layer of Hadamard gates to the first n qubits
for i in range(n):
    cir.h(i)

# Measure all qubits
cir.measure()
# Print the circuit
cir.print_circuit()


# Get the biadjacency matrix and the candidate matrix of the simplified graph
# of the quantum circuit through boolean matrix multiplication
b_circuit, c_circuit = cir.get_biadjacency_and_candidate_matrices()

# Construct the biadjacency matrix and the candidate matrix based on theoretical analysis.
# Note that the calculations below are specifically designed for cases in which the secret string is an all-one string.

# Define some helper matrices
e_00 = numpy.array([[1, 0], [0, 0]], dtype=int)
e_01 = numpy.array([[0, 1], [0, 0]], dtype=int)
e_10 = numpy.array([[0, 0], [1, 0]], dtype=int)
e_11 = numpy.array([[0, 0], [0, 1]], dtype=int)

b_1 = numpy.zeros((n, n), dtype=int)
for i in range(1, n):
    b_1[i][0] += 1
b_2 = numpy.zeros((n, n), dtype=int)
for i in range(0, n):
    for j in range(i, n):
        b_2[i][j] += 1

c_1 = numpy.zeros((n, n), dtype=int)
for i in range(1, n - 1):
    for j in range(i + 1, n):
        c_1[i][j] += 1
c_2 = numpy.zeros((n, n), dtype=int)
for i in range(1, n):
    for j in range(0, i):
        c_2[i][j] += 1
c_3 = numpy.zeros((n, n), dtype=int)
for i in range(0, n - 1):
    for j in range(i + 1, n):
        c_3[i][j] += 1

# Construct the biadjacency matrix
b_theory = numpy.kron(e_00 + e_10, (numpy.identity(n, dtype=int) + b_1)) + numpy.kron(e_01 + e_11, b_2)

# Verify if two biadjacency matrices generated by different approaches are identical
b_difference = b_circuit - b_theory
print("\nThe biadjacency matrices generated by different approaches are identical:", numpy.all(b_difference == 0))

# Construct the candidate matrix
c_theory = numpy.kron(e_00 + e_01, c_1 + c_2) + numpy.kron((e_10 + e_11), c_3)

# Verify if two candidate matrices generated by different approaches are identical
c_difference = c_circuit - c_theory
print("\nThe candidate matrices generated by different approaches are identical:", numpy.all(c_difference == 0))


# Define some helper matrices
f_1 = numpy.zeros([n, n], dtype=int)
for i in range(1, n - 1):
    f_1[i][i + 1] += 1
f_2 = numpy.zeros([n, n], dtype=int)
for i in range(0, n - 1):
    f_2[i][i + 1] += 1

# Construct the matrix corresponding to the added edges in the optimal compilation
op_matrix = numpy.kron(e_00, f_1) + numpy.kron(e_11, f_2)

# Construct the adjacency matrix corresponding to the optimal compilation
zero_matrix = numpy.zeros([qubit_num, qubit_num], dtype=int)
adjacency_matrix = numpy.block([[zero_matrix, b_circuit], [op_matrix, zero_matrix]])

# Iteratively calculate the power of the adjacency matrix
nilpotent = reduce(numpy.matmul, [adjacency_matrix for _ in range(2 * qubit_num)])

# Check whether the adjacency matrix corresponding to the optimal compilation is nilpotent
print("\nThe adjacency matrix corresponding to the optimal compilation is nilpotent:", numpy.all(nilpotent == 0))
